{
  "tags": [
    "computer_architecture",
    "operating_systems",
    "data_structures_and_algorithms",
    "machine_learning",
    "deep_learning",
    "reinforcement_learning",
    "optimization",
    "linear_algebra",
    "probability",
    "robustness_and_uncertainty_for_structured_prediction",
    "concurrency",
    "strings",
    "security",
    "networking",
    "problem_solving",
    "collective_communication",
    "mapreduce",
    "distributed_systems"
  ],
  "notes": [
    {
      "path": "what_is_a_computer.md",
      "tags": [
        "computer_architecture"
      ]
    },
    {
      "path": "binary_addition.md",
      "tags": [
        "computer_architecture"
      ]
    },
    {
      "path": "overflow.md",
      "tags": [
        "computer_architecture"
      ]
    },
    {
      "path": "twos_complement.md",
      "tags": [
        "computer_architecture"
      ]
    },
    {
      "path": "a_tour_of_computer_systems.md",
      "tags": [
        "computer_architecture"
      ]
    },
    {
      "path": "transistors.md",
      "tags": [
        "computer_architecture"
      ]
    },
    {
      "path": "flip_flops.md",
      "tags": [
        "computer_architecture"
      ]
    },
    {
      "path": "synchronous_systems.md",
      "tags": [
        "computer_architecture"
      ]
    },
    {
      "path": "assembly.md",
      "tags": [
        "computer_architecture"
      ]
    },
    {
      "path": "c_memory_management.md",
      "tags": [
        "computer_architecture"
      ]
    },
    {
      "path": "computer_chip.md",
      "tags": [
        "computer_architecture"
      ]
    },
    {
      "path": "floating_point.md",
      "tags": [
        "computer_architecture"
      ]
    },
    {
      "path": "flynns_taxonomy.md",
      "tags": [
        "computer_architecture"
      ]
    },
    {
      "path": "ostep_introduction_to_operating_systems.md",
      "tags": [
        "operating_systems"
      ]
    },
    {
      "path": "concurrency.md",
      "tags": [
        "operating_systems"
      ]
    },
    {
      "path": "multithreading.md",
      "tags": [
        "operating_systems"
      ]
    },
    {
      "path": "ostep_concurrency_and_threads.md",
      "tags": [
        "operating_systems",
        "concurrency"
      ]
    },
    {
      "path": "ostep_locks.md",
      "tags": [
        "operating_systems",
        "concurrency"
      ]
    },
    {
      "path": "ostep_condition_variables.md",
      "tags": [
        "operating_systems",
        "concurrency"
      ]
    },
    {
      "path": "ostep_semaphores.md",
      "tags": [
        "operating_systems",
        "concurrency"
      ]
    },
    {
      "path": "ostep_locked_data_structures.md",
      "tags": [
        "operating_systems",
        "concurrency"
      ]
    },
    {
      "path": "ostep_common_concurrency_problems.md",
      "tags": [
        "operating_systems",
        "concurrency"
      ]
    },
    {
      "path": "ostep_free_space_management.md",
      "tags": [
        "operating_systems"
      ]
    },
    {
      "path": "memory_manager.py",
      "tags": [
        "operating_systems"
      ]
    },
    {
      "path": "buddy_memory_manager.py",
      "tags": [
        "operating_systems"
      ]
    },
    {
      "path": "linked_list_memory_manager.py",
      "tags": [
        "operating_systems"
      ]
    },
    {
      "path": "memory_mapping.md",
      "tags": [
        "operating_systems"
      ]
    },
    {
      "path": "Basic comparison sorting.ipynb",
      "tags": [
        "data_structures_and_algorithms"
      ]
    },
    {
      "path": "Non-comparison sorting.ipynb",
      "tags": [
        "data_structures_and_algorithms"
      ]
    },
    {
      "path": "Merge sort.ipynb",
      "tags": [
        "data_structures_and_algorithms"
      ]
    },
    {
      "path": "quicksort.md",
      "tags": [
        "data_structures_and_algorithms"
      ]
    },
    {
      "path": "Dynamic programming.ipynb",
      "tags": [
        "data_structures_and_algorithms"
      ]
    },
    {
      "path": "Heap.ipynb",
      "tags": [
        "data_structures_and_algorithms"
      ]
    },
    {
      "path": "Trie.ipynb",
      "tags": [
        "data_structures_and_algorithms"
      ]
    },
    {
      "path": "backtracking.md",
      "tags": [
        "data_structures_and_algorithms"
      ]
    },
    {
      "path": "sliding_window.md",
      "tags": [
        "data_structures_and_algorithms"
      ]
    },
    {
      "path": "0-1 Knapsack.ipynb",
      "tags": [
        "data_structures_and_algorithms"
      ]
    },
    {
      "path": "correctness_proof.md",
      "tags": [
        "data_structures_and_algorithms"
      ]
    },
    {
      "path": "calculator.py",
      "tags": [
        "data_structures_and_algorithms"
      ]
    },
    {
      "path": "what_is_machine_learning.md",
      "tags": [
        "machine_learning"
      ]
    },
    {
      "path": "bias_variance_tradeoff.md",
      "tags": [
        "machine_learning"
      ]
    },
    {
      "path": "naive_bayes.md",
      "tags": [
        "machine_learning"
      ]
    },
    {
      "path": "linear_discriminant_analysis.md",
      "tags": [
        "machine_learning"
      ]
    },
    {
      "path": "k_means_clustering.md",
      "tags": [
        "machine_learning"
      ]
    },
    {
      "path": "support_vector_machines.md",
      "tags": [
        "machine_learning"
      ]
    },
    {
      "path": "kernel_trick.md",
      "tags": [
        "machine_learning"
      ]
    },
    {
      "path": "Linear regression.ipynb",
      "tags": [
        "machine_learning"
      ]
    },
    {
      "path": "Logistic regression.ipynb",
      "tags": [
        "machine_learning"
      ]
    },
    {
      "path": "Softmax regression.ipynb",
      "tags": [
        "machine_learning"
      ]
    },
    {
      "path": "mlp.py",
      "tags": [
        "machine_learning"
      ]
    },
    {
      "path": "MLP.ipynb",
      "tags": [
        "machine_learning"
      ]
    },
    {
      "path": "gradient_descent.md",
      "tags": [
        "deep_learning"
      ]
    },
    {
      "path": "automatic_differentiation.md",
      "tags": [
        "deep_learning"
      ]
    },
    {
      "path": "attention.md",
      "tags": [
        "deep_learning"
      ]
    },
    {
      "path": "graph_neural_networks.md",
      "tags": [
        "deep_learning"
      ]
    },
    {
      "path": "data_parallelism.md",
      "tags": [
        "deep_learning"
      ]
    },
    {
      "path": "t5_style_model_parallelism.md",
      "tags": [
        "deep_learning"
      ]
    },
    {
      "path": "pipeline_parallelism.md",
      "tags": [
        "deep_learning"
      ]
    },
    {
      "path": "zero_offload.md",
      "tags": [
        "deep_learning"
      ]
    },
    {
      "path": "zero_dp.md",
      "tags": [
        "deep_learning"
      ]
    },
    {
      "path": "megatron_style_model_parallelism.md",
      "tags": [
        "deep_learning"
      ]
    },
    {
      "path": "mixture_of_experts.md",
      "tags": [
        "deep_learning"
      ]
    },
    {
      "path": "mlp_duplicated.py",
      "tags": [
        "deep_learning"
      ]
    },
    {
      "path": "mlp_dp.py",
      "tags": [
        "deep_learning"
      ]
    },
    {
      "path": "mlp_tp.py",
      "tags": [
        "deep_learning"
      ]
    },
    {
      "path": "mlp_pp.py",
      "tags": [
        "deep_learning"
      ]
    },
    {
      "path": "reinforcement_learning_framework.md",
      "tags": [
        "reinforcement_learning"
      ]
    },
    {
      "path": "reinforcement_learning_objective.md",
      "tags": [
        "reinforcement_learning"
      ]
    },
    {
      "path": "imitation_learning.md",
      "tags": [
        "reinforcement_learning"
      ]
    },
    {
      "path": "problems_with_imitation_learning.md",
      "tags": [
        "reinforcement_learning"
      ]
    },
    {
      "path": "policy_gradients.md",
      "tags": [
        "reinforcement_learning"
      ]
    },
    {
      "path": "policy_gradients_vs_imitation_learning.md",
      "tags": [
        "reinforcement_learning"
      ]
    },
    {
      "path": "linear_algebra_3blue1brown.md",
      "tags": [
        "linear_algebra"
      ]
    },
    {
      "path": "eigendecomposition.md",
      "tags": [
        "linear_algebra"
      ]
    },
    {
      "path": "singular_value_decomposition.md",
      "tags": [
        "linear_algebra"
      ]
    },
    {
      "path": "moore_penrose_pseudoinverse.md",
      "tags": [
        "linear_algebra"
      ]
    },
    {
      "path": "pca.md",
      "tags": [
        "linear_algebra"
      ]
    },
    {
      "path": "critical_points.md",
      "tags": [
        "optimization"
      ]
    },
    {
      "path": "overflow_and_underflow.md",
      "tags": [
        "optimization"
      ]
    },
    {
      "path": "probability_basics.md",
      "tags": [
        "probability"
      ]
    },
    {
      "path": "random_variables.md",
      "tags": [
        "probability"
      ]
    },
    {
      "path": "reliable_maintainable_scalable_applications.md",
      "tags": [
        "distributed_systems"
      ]
    },
    {
      "path": "data_models_and_query_languages.md",
      "tags": [
        "distributed_systems"
      ]
    },
    {
      "path": "log_segments_with_hash_index.md",
      "tags": [
        "distributed_systems"
      ]
    },
    {
      "path": "key_value_store.py",
      "tags": [
        "distributed_systems"
      ]
    },
    {
      "path": "sstables.md",
      "tags": [
        "distributed_systems"
      ]
    },
    {
      "path": "data_warehousing.md",
      "tags": [
        "distributed_systems"
      ]
    },
    {
      "path": "encoding_and_evolution.md",
      "tags": [
        "distributed_systems"
      ]
    },
    {
      "path": "single_leader_replication.md",
      "tags": [
        "distributed_systems"
      ]
    },
    {
      "path": "multi_leader_replication.md",
      "tags": [
        "distributed_systems"
      ]
    },
    {
      "path": "leaderless_replication.md",
      "tags": [
        "distributed_systems"
      ]
    },
    {
      "path": "partitioning.md",
      "tags": [
        "distributed_systems"
      ]
    },
    {
      "path": "batch_processing.md",
      "tags": [
        "distributed_systems"
      ]
    },
    {
      "path": "client_centric_consistency_models.md",
      "tags": [
        "distributed_systems"
      ]
    },
    {
      "path": "hadoop_distributed_file_system.md",
      "tags": [
        "distributed_systems"
      ]
    },
    {
      "path": "kafka.md",
      "tags": [
        "distributed_systems"
      ]
    },
    {
      "path": "rate_limiting.md",
      "tags": [
        "distributed_systems"
      ]
    },
    {
      "path": "selective_sequence_prediction.md",
      "tags": [
        "robustness_and_uncertainty_for_structured_prediction"
      ]
    },
    {
      "path": "data_synthesis_for_language_reward_models.md",
      "tags": [
        "robustness_and_uncertainty_for_structured_prediction"
      ]
    },
    {
      "path": "structured_prediction.md",
      "tags": [
        "robustness_and_uncertainty_for_structured_prediction"
      ]
    },
    {
      "path": "ensemble_methods.md",
      "tags": [
        "robustness_and_uncertainty_for_structured_prediction"
      ]
    },
    {
      "path": "calibration_definitions.md",
      "tags": [
        "robustness_and_uncertainty_for_structured_prediction"
      ]
    },
    {
      "path": "post_hoc_calibration.md",
      "tags": [
        "robustness_and_uncertainty_for_structured_prediction"
      ]
    },
    {
      "path": "decoding_strategies.md",
      "tags": [
        "robustness_and_uncertainty_for_structured_prediction"
      ]
    },
    {
      "path": "maximum_softmax_probability.md",
      "tags": [
        "robustness_and_uncertainty_for_structured_prediction"
      ]
    },
    {
      "path": "selective_prediction.md",
      "tags": [
        "robustness_and_uncertainty_for_structured_prediction"
      ]
    },
    {
      "path": "modeling_model_outputs.md",
      "tags": [
        "robustness_and_uncertainty_for_structured_prediction"
      ]
    },
    {
      "path": "ood_detection.md",
      "tags": [
        "robustness_and_uncertainty_for_structured_prediction"
      ]
    },
    {
      "path": "calibration_for_structured_prediction.md",
      "tags": [
        "robustness_and_uncertainty_for_structured_prediction"
      ]
    },
    {
      "path": "dot_product_attention.py",
      "tags": [
        "deep_learning"
      ]
    },
    {
      "path": "autograd_scalar.py",
      "tags": [
        "deep_learning"
      ]
    },
    {
      "path": "autograd_tensor.py",
      "tags": [
        "deep_learning"
      ]
    },
    {
      "path": "batch_norm.py",
      "tags": [
        "deep_learning"
      ]
    },
    {
      "path": "bellman_ford.py",
      "tags": [
        "data_structures_and_algorithms"
      ]
    },
    {
      "path": "binary_search.py",
      "tags": [
        "data_structures_and_algorithms"
      ]
    },
    {
      "path": "binary_search_tree.py",
      "tags": [
        "data_structures_and_algorithms"
      ]
    },
    {
      "path": "bit_manipulation.py",
      "tags": [
        "data_structures_and_algorithms"
      ]
    },
    {
      "path": "bounded_blocking_queue.py",
      "tags": [
        "concurrency"
      ]
    },
    {
      "path": "breadth_first_search.py",
      "tags": [
        "data_structures_and_algorithms"
      ]
    },
    {
      "path": "categorical_crossentropy.py",
      "tags": [
        "deep_learning"
      ]
    },
    {
      "path": "custom_queue.py",
      "tags": [
        "data_structures_and_algorithms"
      ]
    },
    {
      "path": "dag_relaxation.py",
      "tags": [
        "data_structures_and_algorithms"
      ]
    },
    {
      "path": "deadlock.py",
      "tags": [
        "concurrency"
      ]
    },
    {
      "path": "depth_first_search_iterative.py",
      "tags": [
        "data_structures_and_algorithms"
      ]
    },
    {
      "path": "depth_first_search_recursive.py",
      "tags": [
        "data_structures_and_algorithms"
      ]
    },
    {
      "path": "dijkstra.py",
      "tags": [
        "data_structures_and_algorithms"
      ]
    },
    {
      "path": "floyd_warshall.py",
      "tags": [
        "data_structures_and_algorithms"
      ]
    },
    {
      "path": "dining_philosophers.py",
      "tags": [
        "concurrency"
      ]
    },
    {
      "path": "hash_table.py",
      "tags": [
        "data_structures_and_algorithms"
      ]
    },
    {
      "path": "hash_map_with_linked_list.py",
      "tags": [
        "data_structures_and_algorithms"
      ]
    },
    {
      "path": "heap_sort_in_place.py",
      "tags": [
        "data_structures_and_algorithms"
      ]
    },
    {
      "path": "kth_largest_value.py",
      "tags": [
        "data_structures_and_algorithms"
      ]
    },
    {
      "path": "linked_list.py",
      "tags": [
        "data_structures_and_algorithms"
      ]
    },
    {
      "path": "floyd_cycle_detection.py",
      "tags": [
        "data_structures_and_algorithms"
      ]
    },
    {
      "path": "lru_cache.py",
      "tags": [
        "data_structures_and_algorithms"
      ]
    },
    {
      "path": "producer_consumer.py",
      "tags": [
        "concurrency"
      ]
    },
    {
      "path": "sieve_of_eratosthenes.py",
      "tags": [
        "data_structures_and_algorithms"
      ]
    },
    {
      "path": "softmax.py",
      "tags": [
        "deep_learning"
      ]
    },
    {
      "path": "stack.py",
      "tags": [
        "data_structures_and_algorithms"
      ]
    },
    {
      "path": "thread_error.py",
      "tags": [
        "concurrency"
      ]
    },
    {
      "path": "thread_pool_executor.py",
      "tags": [
        "concurrency"
      ]
    },
    {
      "path": "thread_pool_executor_from_scratch.py",
      "tags": [
        "concurrency"
      ]
    },
    {
      "path": "as_completed.py",
      "tags": [
        "concurrency"
      ]
    },
    {
      "path": "web_crawler.py",
      "tags": [
        "concurrency"
      ]
    },
    {
      "path": "web_crawler_concurrent_with_queue.py",
      "tags": [
        "concurrency"
      ]
    },
    {
      "path": "DataLoader.ipynb",
      "tags": [
        "concurrency"
      ]
    },
    {
      "path": "readers_writers_balanced.py",
      "tags": [
        "concurrency"
      ]
    },
    {
      "path": "k_means.py",
      "tags": [
        "machine_learning"
      ]
    },
    {
      "path": "minhash_lsh.md",
      "tags": [
        "data_structures_and_algorithms",
        "machine_learning"
      ]
    },
    {
      "path": "needleman_wunsch_algorithm.md",
      "tags": [
        "data_structures_and_algorithms",
        "strings"
      ]
    },
    {
      "path": "smith_waterman_algorithm.md",
      "tags": [
        "data_structures_and_algorithms",
        "strings"
      ]
    },
    {
      "path": "String matching.ipynb",
      "tags": [
        "data_structures_and_algorithms",
        "strings"
      ]
    },
    {
      "path": "union_find.py",
      "tags": [
        "data_structures_and_algorithms"
      ]
    },
    {
      "path": "fenwick_tree.py",
      "tags": [
        "data_structures_and_algorithms"
      ]
    },
    {
      "path": "external_merge_sort.py",
      "tags": [
        "data_structures_and_algorithms"
      ]
    },
    {
      "path": "user_authentication.md",
      "tags": [
        "security"
      ]
    },
    {
      "path": "transport_layer_security.md",
      "tags": [
        "security"
      ]
    },
    {
      "path": "socket_programming.md",
      "tags": [
        "networking"
      ]
    },
    {
      "path": "io_multiplexing.md",
      "tags": [
        "networking",
        "operating_systems",
        "concurrency"
      ]
    },
    {
      "path": "http_protocol.md",
      "tags": [
        "networking"
      ]
    },
    {
      "path": "what_happens_when.md",
      "tags": [
        "networking"
      ]
    },
    {
      "path": "http_proxy.md",
      "tags": [
        "networking"
      ]
    },
    {
      "path": "dns_client.py",
      "tags": [
        "networking"
      ]
    },
    {
      "path": "reliable_transport.py",
      "tags": [
        "networking"
      ]
    },
    {
      "path": "traceroute.py",
      "tags": [
        "networking"
      ]
    },
    {
      "path": "how_to_solve_it.md",
      "tags": [
        "problem_solving"
      ]
    },
    {
      "path": "computational_problem_solving.md",
      "tags": [
        "problem_solving"
      ]
    },
    {
      "path": "all_gather.py",
      "tags": [
        "collective_communication"
      ]
    },
    {
      "path": "all_reduce.py",
      "tags": [
        "collective_communication"
      ]
    },
    {
      "path": "broadcast.py",
      "tags": [
        "collective_communication"
      ]
    },
    {
      "path": "gather.py",
      "tags": [
        "collective_communication"
      ]
    },
    {
      "path": "reduce.py",
      "tags": [
        "collective_communication"
      ]
    },
    {
      "path": "scatter.py",
      "tags": [
        "collective_communication"
      ]
    },
    {
      "path": "collective_communication.md",
      "tags": [
        "collective_communication"
      ]
    },
    {
      "path": "mapreduce.py",
      "tags": [
        "distributed_systems",
        "mapreduce"
      ]
    },
    {
      "path": "top_k_words_mapreduce.py",
      "tags": [
        "distributed_systems",
        "mapreduce"
      ]
    },
    {
      "path": "word_count_in_memory.py",
      "tags": [
        "distributed_systems",
        "mapreduce"
      ]
    },
    {
      "path": "word_count_mapreduce.py",
      "tags": [
        "distributed_systems",
        "mapreduce"
      ]
    },
    {
      "path": "word_count_on_disk.py",
      "tags": [
        "distributed_systems",
        "mapreduce"
      ]
    }
  ]
}
