{
  "tags": [
    "operating_systems",
    "data_structures_and_algorithms",
    "deep_learning",
    "reinforcement_learning",
    "linear_algebra",
    "probability",
    "concurrency",
    "strings",
    "security",
    "networking",
    "problem_solving",
    "collective_communication",
    "mapreduce",
    "distributed_systems",
    "computer_systems"
  ],
  "notes": [
    {
      "path": "what_is_a_computer.md",
      "tags": [
        "computer_systems"
      ]
    },
    {
      "path": "transistors.md",
      "tags": [
        "computer_systems"
      ]
    },
    {
      "path": "analog_and_digital_computing.md",
      "tags": [
        "computer_systems"
      ]
    },
    {
      "path": "binary_arithmetic.md",
      "tags": [
        "computer_systems"
      ]
    },
    {
      "path": "floating_point_representation.md",
      "tags": [
        "computer_systems"
      ]
    },
    {
      "path": "floating_point_overflow_and_underflow.md",
      "tags": [
        "computer_systems"
      ]
    },
    {
      "path": "assembly.md",
      "tags": [
        "computer_systems"
      ]
    },
    {
      "path": "c.md",
      "tags": [
        "computer_systems"
      ]
    },
    {
      "path": "bytes_in_python.md",
      "tags": [
        "computer_systems"
      ]
    },
    {
      "path": "character_encoding_in_python.md",
      "tags": [
        "computer_systems"
      ]
    },
    {
      "path": "data_representation.md",
      "tags": [
        "computer_systems"
      ]
    },
    {
      "path": "branch_prediction.md",
      "tags": [
        "computer_systems"
      ]
    },
    {
      "path": "memory_hierarchy.md",
      "tags": [
        "computer_systems"
      ]
    },
    {
      "path": "optimizing_program_performance.md",
      "tags": [
        "computer_systems"
      ]
    },
    {
      "path": "nand2tetris.md",
      "tags": [
        "computer_systems"
      ]
    },
    {
      "path": "flip_flops.md",
      "tags": [
        "computer_systems"
      ]
    },
    {
      "path": "ostep_introduction_to_operating_systems.md",
      "tags": [
        "operating_systems"
      ]
    },
    {
      "path": "concurrency.md",
      "tags": [
        "concurrency"
      ]
    },
    {
      "path": "multithreading.md",
      "tags": [
        "concurrency"
      ]
    },
    {
      "path": "ostep_concurrency_and_threads.md",
      "tags": [
        "operating_systems",
        "concurrency"
      ]
    },
    {
      "path": "ostep_locks.md",
      "tags": [
        "operating_systems",
        "concurrency"
      ]
    },
    {
      "path": "ostep_condition_variables.md",
      "tags": [
        "operating_systems",
        "concurrency"
      ]
    },
    {
      "path": "ostep_semaphores.md",
      "tags": [
        "operating_systems",
        "concurrency"
      ]
    },
    {
      "path": "ostep_locked_data_structures.md",
      "tags": [
        "operating_systems",
        "concurrency"
      ]
    },
    {
      "path": "ostep_common_concurrency_problems.md",
      "tags": [
        "operating_systems",
        "concurrency"
      ]
    },
    {
      "path": "ostep_free_space_management.md",
      "tags": [
        "operating_systems"
      ]
    },
    {
      "path": "ostep_memory_virtualization.md",
      "tags": [
        "operating_systems"
      ]
    },
    {
      "path": "memory_manager.py",
      "tags": [
        "operating_systems"
      ]
    },
    {
      "path": "buddy_memory_manager.py",
      "tags": [
        "operating_systems"
      ]
    },
    {
      "path": "linked_list_memory_manager.py",
      "tags": [
        "operating_systems"
      ]
    },
    {
      "path": "memory_mapping.md",
      "tags": [
        "operating_systems"
      ]
    },
    {
      "path": "Basic comparison sorting.ipynb",
      "tags": [
        "data_structures_and_algorithms"
      ]
    },
    {
      "path": "Non-comparison sorting.ipynb",
      "tags": [
        "data_structures_and_algorithms"
      ]
    },
    {
      "path": "Merge sort.ipynb",
      "tags": [
        "data_structures_and_algorithms"
      ]
    },
    {
      "path": "quicksort.md",
      "tags": [
        "data_structures_and_algorithms"
      ]
    },
    {
      "path": "Dynamic programming.ipynb",
      "tags": [
        "data_structures_and_algorithms"
      ]
    },
    {
      "path": "Heap.ipynb",
      "tags": [
        "data_structures_and_algorithms"
      ]
    },
    {
      "path": "Trie.ipynb",
      "tags": [
        "data_structures_and_algorithms"
      ]
    },
    {
      "path": "backtracking.md",
      "tags": [
        "data_structures_and_algorithms"
      ]
    },
    {
      "path": "sliding_window.md",
      "tags": [
        "data_structures_and_algorithms"
      ]
    },
    {
      "path": "0-1 Knapsack.ipynb",
      "tags": [
        "data_structures_and_algorithms"
      ]
    },
    {
      "path": "correctness_proof.md",
      "tags": [
        "data_structures_and_algorithms"
      ]
    },
    {
      "path": "calculator.py",
      "tags": [
        "data_structures_and_algorithms"
      ]
    },
    {
      "path": "Linear regression.ipynb",
      "tags": [
        "deep_learning"
      ]
    },
    {
      "path": "Logistic regression.ipynb",
      "tags": [
        "deep_learning"
      ]
    },
    {
      "path": "Softmax regression.ipynb",
      "tags": [
        "deep_learning"
      ]
    },
    {
      "path": "mlp.py",
      "tags": [
        "deep_learning"
      ]
    },
    {
      "path": "MLP.ipynb",
      "tags": [
        "deep_learning"
      ]
    },
    {
      "path": "gradient_descent.md",
      "tags": [
        "deep_learning"
      ]
    },
    {
      "path": "automatic_differentiation.md",
      "tags": [
        "deep_learning"
      ]
    },
    {
      "path": "data_parallelism.md",
      "tags": [
        "deep_learning"
      ]
    },
    {
      "path": "t5_style_model_parallelism.md",
      "tags": [
        "deep_learning"
      ]
    },
    {
      "path": "pipeline_parallelism.md",
      "tags": [
        "deep_learning"
      ]
    },
    {
      "path": "megatron_style_model_parallelism.md",
      "tags": [
        "deep_learning"
      ]
    },
    {
      "path": "mixture_of_experts.md",
      "tags": [
        "deep_learning"
      ]
    },
    {
      "path": "mlp_duplicated.py",
      "tags": [
        "deep_learning"
      ]
    },
    {
      "path": "mlp_dp.py",
      "tags": [
        "deep_learning"
      ]
    },
    {
      "path": "mlp_tp.py",
      "tags": [
        "deep_learning"
      ]
    },
    {
      "path": "mlp_pp.py",
      "tags": [
        "deep_learning"
      ]
    },
    {
      "path": "embedding_lookup.py",
      "tags": [
        "deep_learning"
      ]
    },
    {
      "path": "reinforcement_learning_framework.md",
      "tags": [
        "reinforcement_learning"
      ]
    },
    {
      "path": "reinforcement_learning_objective.md",
      "tags": [
        "reinforcement_learning"
      ]
    },
    {
      "path": "imitation_learning.md",
      "tags": [
        "reinforcement_learning"
      ]
    },
    {
      "path": "problems_with_imitation_learning.md",
      "tags": [
        "reinforcement_learning"
      ]
    },
    {
      "path": "policy_gradients.md",
      "tags": [
        "reinforcement_learning"
      ]
    },
    {
      "path": "policy_gradients_vs_imitation_learning.md",
      "tags": [
        "reinforcement_learning"
      ]
    },
    {
      "path": "linear_algebra_3blue1brown.md",
      "tags": [
        "linear_algebra"
      ]
    },
    {
      "path": "eigendecomposition.md",
      "tags": [
        "linear_algebra"
      ]
    },
    {
      "path": "singular_value_decomposition.md",
      "tags": [
        "linear_algebra"
      ]
    },
    {
      "path": "moore_penrose_pseudoinverse.md",
      "tags": [
        "linear_algebra"
      ]
    },
    {
      "path": "pca.md",
      "tags": [
        "linear_algebra"
      ]
    },
    {
      "path": "probability_basics.md",
      "tags": [
        "probability"
      ]
    },
    {
      "path": "random_variables.md",
      "tags": [
        "probability"
      ]
    },
    {
      "path": "reliable_maintainable_scalable_applications.md",
      "tags": [
        "distributed_systems"
      ]
    },
    {
      "path": "data_models_and_query_languages.md",
      "tags": [
        "distributed_systems"
      ]
    },
    {
      "path": "log_segments_with_hash_index.md",
      "tags": [
        "distributed_systems"
      ]
    },
    {
      "path": "key_value_store.py",
      "tags": [
        "distributed_systems"
      ]
    },
    {
      "path": "sstables.md",
      "tags": [
        "distributed_systems"
      ]
    },
    {
      "path": "data_warehousing.md",
      "tags": [
        "distributed_systems"
      ]
    },
    {
      "path": "encoding_and_evolution.md",
      "tags": [
        "distributed_systems"
      ]
    },
    {
      "path": "single_leader_replication.md",
      "tags": [
        "distributed_systems"
      ]
    },
    {
      "path": "multi_leader_replication.md",
      "tags": [
        "distributed_systems"
      ]
    },
    {
      "path": "leaderless_replication.md",
      "tags": [
        "distributed_systems"
      ]
    },
    {
      "path": "partitioning.md",
      "tags": [
        "distributed_systems"
      ]
    },
    {
      "path": "batch_processing.md",
      "tags": [
        "distributed_systems"
      ]
    },
    {
      "path": "client_centric_consistency_models.md",
      "tags": [
        "distributed_systems"
      ]
    },
    {
      "path": "hadoop_distributed_file_system.md",
      "tags": [
        "distributed_systems"
      ]
    },
    {
      "path": "kafka.md",
      "tags": [
        "distributed_systems"
      ]
    },
    {
      "path": "rate_limiting.md",
      "tags": [
        "distributed_systems"
      ]
    },
    {
      "path": "dot_product_attention.py",
      "tags": [
        "deep_learning"
      ]
    },
    {
      "path": "autograd_scalar.py",
      "tags": [
        "deep_learning"
      ]
    },
    {
      "path": "autograd_tensor.py",
      "tags": [
        "deep_learning"
      ]
    },
    {
      "path": "batch_norm.py",
      "tags": [
        "deep_learning"
      ]
    },
    {
      "path": "bellman_ford.py",
      "tags": [
        "data_structures_and_algorithms"
      ]
    },
    {
      "path": "binary_search.py",
      "tags": [
        "data_structures_and_algorithms"
      ]
    },
    {
      "path": "binary_search_tree.py",
      "tags": [
        "data_structures_and_algorithms"
      ]
    },
    {
      "path": "bit_manipulation.py",
      "tags": [
        "data_structures_and_algorithms"
      ]
    },
    {
      "path": "bounded_blocking_queue.py",
      "tags": [
        "concurrency"
      ]
    },
    {
      "path": "breadth_first_search.py",
      "tags": [
        "data_structures_and_algorithms"
      ]
    },
    {
      "path": "categorical_crossentropy.py",
      "tags": [
        "deep_learning"
      ]
    },
    {
      "path": "custom_queue.py",
      "tags": [
        "data_structures_and_algorithms"
      ]
    },
    {
      "path": "dag_relaxation.py",
      "tags": [
        "data_structures_and_algorithms"
      ]
    },
    {
      "path": "deadlock.py",
      "tags": [
        "concurrency"
      ]
    },
    {
      "path": "multithreaded_merge_sort.py",
      "tags": [
        "concurrency"
      ]
    },
    {
      "path": "depth_first_search_iterative.py",
      "tags": [
        "data_structures_and_algorithms"
      ]
    },
    {
      "path": "depth_first_search_recursive.py",
      "tags": [
        "data_structures_and_algorithms"
      ]
    },
    {
      "path": "dijkstra.py",
      "tags": [
        "data_structures_and_algorithms"
      ]
    },
    {
      "path": "floyd_warshall.py",
      "tags": [
        "data_structures_and_algorithms"
      ]
    },
    {
      "path": "dining_philosophers.py",
      "tags": [
        "concurrency"
      ]
    },
    {
      "path": "hash_table.py",
      "tags": [
        "data_structures_and_algorithms"
      ]
    },
    {
      "path": "hash_map_with_linked_list.py",
      "tags": [
        "data_structures_and_algorithms"
      ]
    },
    {
      "path": "heap_sort_in_place.py",
      "tags": [
        "data_structures_and_algorithms"
      ]
    },
    {
      "path": "kth_largest_value.py",
      "tags": [
        "data_structures_and_algorithms"
      ]
    },
    {
      "path": "linked_list.py",
      "tags": [
        "data_structures_and_algorithms"
      ]
    },
    {
      "path": "floyd_cycle_detection.py",
      "tags": [
        "data_structures_and_algorithms"
      ]
    },
    {
      "path": "lru_cache.py",
      "tags": [
        "data_structures_and_algorithms"
      ]
    },
    {
      "path": "producer_consumer.py",
      "tags": [
        "concurrency"
      ]
    },
    {
      "path": "sieve_of_eratosthenes.py",
      "tags": [
        "data_structures_and_algorithms"
      ]
    },
    {
      "path": "softmax.py",
      "tags": [
        "deep_learning"
      ]
    },
    {
      "path": "stack.py",
      "tags": [
        "data_structures_and_algorithms"
      ]
    },
    {
      "path": "thread_error.py",
      "tags": [
        "concurrency"
      ]
    },
    {
      "path": "thread_pool_executor.py",
      "tags": [
        "concurrency"
      ]
    },
    {
      "path": "thread_pool_executor_from_scratch.py",
      "tags": [
        "concurrency"
      ]
    },
    {
      "path": "as_completed.py",
      "tags": [
        "concurrency"
      ]
    },
    {
      "path": "web_crawler.py",
      "tags": [
        "concurrency"
      ]
    },
    {
      "path": "web_crawler_concurrent_with_queue.py",
      "tags": [
        "concurrency"
      ]
    },
    {
      "path": "DataLoader.ipynb",
      "tags": [
        "concurrency"
      ]
    },
    {
      "path": "readers_writers_balanced.py",
      "tags": [
        "concurrency"
      ]
    },
    {
      "path": "minhash_lsh.md",
      "tags": [
        "data_structures_and_algorithms"
      ]
    },
    {
      "path": "needleman_wunsch_algorithm.md",
      "tags": [
        "data_structures_and_algorithms",
        "strings"
      ]
    },
    {
      "path": "smith_waterman_algorithm.md",
      "tags": [
        "data_structures_and_algorithms",
        "strings"
      ]
    },
    {
      "path": "String matching.ipynb",
      "tags": [
        "data_structures_and_algorithms",
        "strings"
      ]
    },
    {
      "path": "union_find.py",
      "tags": [
        "data_structures_and_algorithms"
      ]
    },
    {
      "path": "fenwick_tree.py",
      "tags": [
        "data_structures_and_algorithms"
      ]
    },
    {
      "path": "external_merge_sort.py",
      "tags": [
        "data_structures_and_algorithms"
      ]
    },
    {
      "path": "user_authentication.md",
      "tags": [
        "security"
      ]
    },
    {
      "path": "transport_layer_security.md",
      "tags": [
        "security"
      ]
    },
    {
      "path": "socket_programming.md",
      "tags": [
        "networking"
      ]
    },
    {
      "path": "io_multiplexing.md",
      "tags": [
        "networking",
        "operating_systems",
        "concurrency"
      ]
    },
    {
      "path": "http_protocol.md",
      "tags": [
        "networking"
      ]
    },
    {
      "path": "what_happens_when.md",
      "tags": [
        "networking"
      ]
    },
    {
      "path": "http_proxy.md",
      "tags": [
        "networking"
      ]
    },
    {
      "path": "dns_client.py",
      "tags": [
        "networking"
      ]
    },
    {
      "path": "reliable_transport.py",
      "tags": [
        "networking"
      ]
    },
    {
      "path": "traceroute.py",
      "tags": [
        "networking"
      ]
    },
    {
      "path": "how_to_solve_it.md",
      "tags": [
        "problem_solving"
      ]
    },
    {
      "path": "computational_problem_solving.md",
      "tags": [
        "problem_solving"
      ]
    },
    {
      "path": "all_gather.py",
      "tags": [
        "collective_communication"
      ]
    },
    {
      "path": "all_reduce.py",
      "tags": [
        "collective_communication"
      ]
    },
    {
      "path": "broadcast.py",
      "tags": [
        "collective_communication"
      ]
    },
    {
      "path": "gather.py",
      "tags": [
        "collective_communication"
      ]
    },
    {
      "path": "reduce.py",
      "tags": [
        "collective_communication"
      ]
    },
    {
      "path": "scatter.py",
      "tags": [
        "collective_communication"
      ]
    },
    {
      "path": "collective_communication.md",
      "tags": [
        "collective_communication"
      ]
    },
    {
      "path": "mapreduce.py",
      "tags": [
        "distributed_systems",
        "mapreduce"
      ]
    },
    {
      "path": "top_k_words_mapreduce.py",
      "tags": [
        "distributed_systems",
        "mapreduce"
      ]
    },
    {
      "path": "word_count_in_memory.py",
      "tags": [
        "distributed_systems",
        "mapreduce"
      ]
    },
    {
      "path": "word_count_mapreduce.py",
      "tags": [
        "distributed_systems",
        "mapreduce"
      ]
    },
    {
      "path": "word_count_on_disk.py",
      "tags": [
        "distributed_systems",
        "mapreduce"
      ]
    },
    {
      "path": "asyncio.md",
      "tags": [
        "concurrency"
      ]
    }
  ]
}
